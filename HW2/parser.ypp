%{

#include "output.hpp"
extern int yylineno; 
void yyerror(char const *s);
 int yylex();


%}

%nonassoc LBRACE RBRACE SC ASSIGN IF ELSE WHILE BREAK CONTINUE RETURN INT BYTE BOOL TRUE FALSE BINOP AND OR NOT
%nonassoc TYPE ID STRING
%nonassoc  NUM B
%left RELOP
%left '+' '-'
%left '*' '/'
%nonassoc CAST
%nonassoc DOUBLEOP
%nonassoc LPAREN RPAREN 
%%

Program:
    Statements {}
    ;

Statements:
    Statement {output::printProductionRule(1);}
    | Statements Statement  {output::printProductionRule(2);}
    ;

Statement:
    LBRACE Statements RBRACE {output::printProductionRule(3);}
    | Type ID SC {output::printProductionRule(4);}
    | Type ID ASSIGN Exp SC {output::printProductionRule(5);}
    | ID ASSIGN Exp SC {output::printProductionRule(6);}
    | Call SC {output::printProductionRule(7);}
    | RETURN SC {output::printProductionRule(8);}
    | IF LPAREN Exp RPAREN Statement {output::printProductionRule(9);}

    | WHILE LPAREN Exp RPAREN Statement {output::printProductionRule(10);}
    | BREAK SC {output::printProductionRule(11);}
    | CONTINUE SC {output::printProductionRule(12);}
    ;

Call:
    ID LPAREN Exp RPAREN {output::printProductionRule(13);}
    ;

Type:
    INT     {output::printProductionRule(14);}
    | BYTE  {output::printProductionRule(15);}
    | BOOL {output::printProductionRule(16);}
    ;

Exp:
    LPAREN Exp RPAREN {output::printProductionRule(17);}
    | Exp BINOP Exp {output::printProductionRule(18);}
    | ID {output::printProductionRule(19);}
    | Call {output::printProductionRule(20);}
    | NUM {output::printProductionRule(21);}
    | NUM B {output::printProductionRule(22);}
    | STRING {output::printProductionRule(23);}
    | TRUE {output::printProductionRule(24);}
    | FALSE     {output::printProductionRule(25);}
    | NOT Exp  {output::printProductionRule(26);}
    | Exp AND Exp  {output::printProductionRule(27);}
    | Exp OR Exp  {output::printProductionRule(28);}
    | Exp RELOP Exp  {output::printProductionRule(29);}
    | LPAREN Type RPAREN Exp  {output::printProductionRule(30);}
    ;

%%

// You can include C++ code here that defines any additional functions or data structures used above
int main()
{
    return yyparse();
} 

void yyerror(char const * s)
{
    printf("Error ");
} 




